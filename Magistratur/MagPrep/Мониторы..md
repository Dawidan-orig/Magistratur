>  Представьте себе, что две процедуры down в программе про- изводителя поменялись местами, так что значение мютекса буфера было уменьшено раньше, чем мютекс собственной опустошённости. Если буфер был заполнен, производитель блокируется.
>  Соответственно, в следующий раз, когда потребитель обратится к буферу, он выполнит down с переменной mutex буфера, равной 0, и тоже заблокируется. Оба процесса заблокированы навсегда. 
[[Танненбаум_ОС.pdf#page=145&selection=118,4,184,1|Танненбаум_ОС, страница 145]]

> Монитор — набор процедур, переменных и других структур данных, объединенных в особый модуль или пакет. Касается только языков высокого уровня. Процессы могут вызывать процедуры монитора, но у процедур, объявленных вне монитора, нет прямого доступа к внутренним структурам данных монитора.
> 
> При обращении к монитору в любой момент времени активным может быть только один процесс. Мониторы являются структурным компонентом языка программирования, поэтому компилятор знает, что обрабатывать вызовы процедур монитора следует иначе, чем вызовы остальных процедур. Обычно при вызове процедуры монитора первые несколько команд процедуры проверяют, нет ли в мониторе активного процесса. Если активный процесс есть, вызывающему процессу придется подождать, в противном случае запрос удовлетворяется.
> 
> Решение заключается во введении переменных состояния и двух операций, wait и signal. Когда процедура монитора обнаруживает, что она не в состоянии продолжать работу (например, производитель выясняет, что буфер заполнен), она выполняет операцию wait на какой-либо переменной состояния, скажем, full. Это приводит к блокировке вызывающего процесса и позволяет другому процессу войти в монитор.
