Состоит конвейер из этапов, и вся прелесть в том, что на этапе n процессор разом делает действие для этапа n+1 следующего конвейера, и n+2 следующих двух.
То-есть конвейеры кладутся друг на друга со смещением в 1 этап, что позволяет ооочень здорово оптимизировать подачу и выполнение команд.
i486: {Загрузка}->{Основное декодирование (?)} -> {Вторичное декодирование (?)} -> {Выполнение} -> {Запись результата в регистры}

Конвеерное выполнение операций ( #нейро )
- **Конвейер** — способ организации выполнения команд, при котором весь процесс разбивается на последовательные этапы (стадии), например:
    1. Считывание команды (Instruction Fetch, IF)
    2. Декодирование команды (Instruction Decode, ID)
    3. Считывание операндов (Operand Read, OR)
    4. Выполнение (Execute, EX)
    5. Запись результата (Write Back, WB)

> В действительности процесс выборки с упреждением подразделяет выполнение команды на два этапа: вызов и собственно выполнение. Идея конвейера еще больше продвинула эту стратегию вперед. Теперь команда подразделялась уже не на два, а на несколько этапов, каждый из которых выполнялся определенной частью аппаратного обеспечения, причем все эти части могли работать параллельно.
[[Танненбаум_Общая архитектура.pdf#page=64&selection=16,0,24,77|Танненбаум_Общая архитектура, страница 64]]

![[IMG_Конвейер из 5 стадий.png]]

Параллельное выполнение операций:
Если операции не разделяют одно и то же адресное пространство (За что отвечает, вообще-то, операционная система), то эти две операции можно выполнить разными ядрами процессора.

> Каждый конвейер содержит АЛУ для параллельных операций. Чтобы выполняться парал- лельно, две команды не должны конфликтовать при использовании ресурсов (на- пример, регистров), и ни одна из них не должна зависеть от результата выполнения другой

[[Танненбаум_Общая архитектура.pdf#page=65&selection=43,68,47,10|Танненбаум_Общая архитектура, страница 65]]