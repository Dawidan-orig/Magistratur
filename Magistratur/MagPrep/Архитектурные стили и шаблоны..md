Вот это уже точно одна из тех вещей, которые программист находит для себя сам. Стиль ведения архитектуры в разных системах вообще разный, хотя, несомненно, есть best-practice'ы. Но не существует волшебной пилюли, которая позволила бы решить все проблемы сразу.

Я нахожу ответ в определении стиля как "Сделай гибрид из всего", то-есть надо определять позитивные и негативные стороны каждого стиля, подхода и шаблона исходя из их влияние на решение каждой задачи.

Параметров по своей сути три:
- Гибкость (Какое количество различных задач может решать система?), 
- Эффективность (Насколько быстро система решает задачи?), 
- Расширяемость (Насколько мало кода придётся переписать, чтобы дать системе новые возможности?)

Так вот, стили:
- Монолит, тесная связь в компонентах, но малопригодно для расширения
- Многослойная архитектура (Примерами тому ModelViewController), разделение на зоны ответственности, по сути
- Микросервисная (Большой набор мелких независимых сервисов, и один универсальный контроллер над всеми)
- Декомпозиция на системы и подсистемы, модульная организация
- Централизация-Децентрализация. Логика через системы, завязанные на один ключевой узел (менеджер), ещё может называться "Клиент-серверной" архитектурой, либо системы, в которых объекты или сущности заполняют рабочее пространство равномерно и взаимодействуют исходя из заложенного поведения


Шаблоны, речь скорее всего про шаблоны ООП.
Их существует три типа: Порождающие, Структурные и Поведенческие. Паттерны позволяют организовать объекты определённым, узнаваемым образом, что оптимизирует разработку и даёт больше расширяемости.
Приведу несколько примеров от каждого типа.
Порождающие (Создание новых объектов более простыми способами):
- Фабрика (Предоставляет функции для быстрого создания готовых объектов)
- Строитель (Даёт возможность собирать объект по частям, создавая только нужные)
- Прототип (Копирование объектов без необходимости вдаваться в реализацию)
Структурные (Часть общей архитектуры, связывание систем между собой)
- Адаптер (Объединение объектов с несовместимыми интерфейсами)
- Фасад (Простой интерфейс к сложной системе)
- Легковес (Объединение хранимой в ОЗУ памяти разных объектов через использование единого контекста)
Поведенческие (Контроль работы объекты)
- Команда (Разделение поведения объекта на фрагменты, которые могут быть отменены с восстановлением состояния, логированы и поставлены в очередь)
- Снимок (Восстановление прошлого состояния ряда объектов)
- Наблюдатель (Механизм подписки, который позволяет реагировать на происходящие в других объектах события)